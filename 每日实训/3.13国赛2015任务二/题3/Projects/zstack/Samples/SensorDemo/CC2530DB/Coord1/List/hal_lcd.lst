###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.40194/W32 for 8051         14/Mar/2017  10:37:44 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\COMPONENTS\hal\ #
#                          target\CC2530EB\hal_lcd.c                          #
#    Command line       =  -f F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zst #
#                          ack\Samples\SensorDemo\CC2530DB\..\..\..\Tools\CC2 #
#                          530DB\f8wCoord.cfg (-DCPU32MHZ -DROOT=__near_func  #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f       #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\..\..\Tools\CC2530 #
#                          DB\f8wConfig.cfg (-DSECURE=0                       #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00100000                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x8888                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\COMPONENTS\hal\ #
#                          target\CC2530EB\hal_lcd.c -D ZIGBEEPRO -D          #
#                          HOLD_AUTO_START -D BUILD_ALL_DEVICES -D REFLECTOR  #
#                          -D NV_INIT -D NV_RESTORE -D ZTOOL_P1 -D xMT_TASK   #
#                          -D DEVICE_LOGICAL_TYPE=0 -D LOG_TYPE=0 -D          #
#                          xLCD_SUPPORTED -D xMT_TASK -lC                     #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\Coord1\List\ -lA      #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\Coord1\List\          #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\Coord1\Obj\ -e        #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zst #
#                          ack\Samples\SensorDemo\CC2530DB\ -I                #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\SOURCE\ -I         #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\MYAPP\ -I          #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\sensor_drv\ -I     #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\..\..\ZMAIN\TI2530 #
#                          DB\ -I F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects #
#                          \zstack\Samples\SensorDemo\CC2530DB\..\..\..\..\.. #
#                          \COMPONENTS\MT\ -I F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\ #
#                          Ìâ3\Projects\zstack\Samples\SensorDemo\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\HAL\INCLUDE\ -I            #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\..\..\..\..\COMPON #
#                          ENTS\HAL\TARGET\CC2530EB\ -I                       #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\..\..\..\..\COMPON #
#                          ENTS\OSAL\MCU\CCSOC\ -I F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎ #
#                          Îñ¶þ\Ìâ3\Projects\zstack\Samples\SensorDemo\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\ -I      #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\..\..\..\..\COMPON #
#                          ENTS\STACK\AF\ -I F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ì #
#                          â3\Projects\zstack\Samples\SensorDemo\CC2530DB\..\ #
#                          ..\..\..\..\COMPONENTS\STACK\NWK\ -I               #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\..\..\..\..\COMPON #
#                          ENTS\STACK\SEC\ -I F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\ #
#                          Ìâ3\Projects\zstack\Samples\SensorDemo\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\STACK\SAPI\ -I             #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\..\..\..\..\COMPON #
#                          ENTS\STACK\SYS\ -I F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\ #
#                          Ìâ3\Projects\zstack\Samples\SensorDemo\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\STACK\ZDO\ -I              #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\..\..\..\..\COMPON #
#                          ENTS\ZMAC\F8W\ -I F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ì #
#                          â3\Projects\zstack\Samples\SensorDemo\CC2530DB\..\ #
#                          ..\..\..\..\COMPONENTS\ZMAC\ -I                    #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\..\..\..\..\COMPON #
#                          ENTS\SERVICES\SADDR\ -I F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎ #
#                          Îñ¶þ\Ìâ3\Projects\zstack\Samples\SensorDemo\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\SERVICES\SDATA\ -I    #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\..\..\..\..\COMPON #
#                          ENTS\MAC\INCLUDE\ -I F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶ #
#                          þ\Ìâ3\Projects\zstack\Samples\SensorDemo\CC2530DB\ #
#                          ..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\ -I       #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\..\..\..\..\COMPON #
#                          ENTS\MAC\LOW_LEVEL\srf04\ -I                       #
#                          F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\..\..\..\..\..\COMPON #
#                          ENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -Ohz         #
#                          --require_prototypes                               #
#    List file          =  F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\Coord1\List\hal_lcd.l #
#                          st                                                 #
#    Object file        =  F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\Projects\zstack #
#                          \Samples\SensorDemo\CC2530DB\Coord1\Obj\hal_lcd.r5 #
#                          1                                                  #
#                                                                             #
#                                                                             #
###############################################################################

F:\Ã¿ÈÕÊµÑµ\3.13¹úÈü2015ÈÎÎñ¶þ\Ìâ3\COMPONENTS\hal\target\CC2530EB\hal_lcd.c
      1          /**************************************************************************************************
      2            Filename:       hal_lcd.c
      3            Revised:        $Date: 2009-11-09 20:03:17 -0800 (Mon, 09 Nov 2009) $
      4            Revision:       $Revision: 21106 $
      5          
      6            Description:    This file contains the interface to the HAL LCD Service.
      7          
      8          
      9            Copyright 2007 - 2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41           *                                           INCLUDES
     42           **************************************************************************************************/
     43          #include "hal_types.h"
     44          #include "hal_lcd.h"
     45          #include "OSAL.h"
     46          #include "OnBoard.h"
     47          #include "hal_assert.h"
     48          
     49          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
     50            #include "DebugTrace.h"
     51          #endif
     52          
     53          /**************************************************************************************************
     54           *                                          CONSTANTS
     55           **************************************************************************************************/
     56          /*
     57            LCD pins
     58          
     59            //control
     60            P0.0 - LCD_MODE
     61            P1.1 - LCD_FLASH_RESET
     62            P1.2 - LCD_CS
     63          
     64            //spi
     65            P1.5 - CLK
     66            P1.6 - MOSI
     67            P1.7 - MISO
     68          */
     69          
     70          /* LCD Control lines */
     71          #define HAL_LCD_MODE_PORT 0
     72          #define HAL_LCD_MODE_PIN  0
     73          
     74          #define HAL_LCD_RESET_PORT 1
     75          #define HAL_LCD_RESET_PIN  1
     76          
     77          #define HAL_LCD_CS_PORT 1
     78          #define HAL_LCD_CS_PIN  2
     79          
     80          /* LCD SPI lines */
     81          #define HAL_LCD_CLK_PORT 1
     82          #define HAL_LCD_CLK_PIN  5
     83          
     84          #define HAL_LCD_MOSI_PORT 1
     85          #define HAL_LCD_MOSI_PIN  6
     86          
     87          #define HAL_LCD_MISO_PORT 1
     88          #define HAL_LCD_MISO_PIN  7
     89          
     90          /* SPI settings */
     91          #define HAL_SPI_CLOCK_POL_LO       0x00
     92          #define HAL_SPI_CLOCK_PHA_0        0x00
     93          #define HAL_SPI_TRANSFER_MSB_FIRST 0x20
     94          
     95          /* LCD lines */
     96          #define LCD_MAX_LINE_COUNT              3
     97          #define LCD_MAX_LINE_LENGTH             16
     98          #define LCD_MAX_BUF                     25
     99          
    100          /* Defines for HW LCD */
    101          
    102          /* Set power save mode */
    103          #define OSC_OFF                         0x00
    104          #define OSC_ON                          0x01
    105          #define POWER_SAVE_OFF                  0x00
    106          #define POWER_SAVE_ON                   0x02
    107          #define SET_POWER_SAVE_MODE(options)    HalLcd_HW_Control(0x0C | (options))
    108          
    109          /* Function Set */
    110          #define CGROM                           0x00
    111          #define CGRAM                           0x01
    112          #define COM_FORWARD                     0x00
    113          #define COM_BACKWARD                    0x02
    114          #define TWO_LINE                        0x00
    115          #define THREE_LINE                      0x04
    116          #define FUNCTION_SET(options)           HalLcd_HW_Control(0x10 | (options))
    117          
    118          /* Set Display Start Line */
    119          #define LINE1                           0x00
    120          #define LINE2                           0x01
    121          #define LINE3                           0x02
    122          #define LINE4                           0x03
    123          #define SET_DISPLAY_START_LINE(line)    HalLcd_HW_Control(0x18 | (line))
    124          
    125          /* Bias control */
    126          #define BIAS_1_5                        0x00
    127          #define BIAS_1_4                        0x01
    128          #define SET_BIAS_CTRL(bias)             HalLcd_HW_Control(0x1C | (bias))
    129          
    130          /* Power control */
    131          #define VOLTAGE_DIVIDER_OFF             0x00
    132          #define VOLTAGE_DIVIDER_ON              0x01
    133          #define CONVERTER_AND_REG_OFF           0x00
    134          #define CONVERTER_AND_REG_ON            0x04
    135          #define SET_POWER_CTRL(options)         HalLcd_HW_Control(0x20 | (options))
    136          
    137          // Set display control
    138          #define DISPLAY_CTRL_ON                 0x01
    139          #define DISPLAY_CTRL_OFF                0x00
    140          #define DISPLAY_CTRL_BLINK_ON           0x02
    141          #define DISPLAY_CTRL_BLINK_OFF          0x00
    142          #define DISPLAY_CTRL_CURSOR_ON          0x04
    143          #define DISPLAY_CTRL_CURSOR_OFF         0x00
    144          #define SET_DISPLAY_CTRL(options)       HalLcd_HW_Control(0x28 | (options))
    145          
    146          /* Set DD/ CGRAM address */
    147          #define SET_DDRAM_ADDR(charIndex)       HalLcd_HW_Control(0x80 | (charIndex))
    148          #define SET_GCRAM_CHAR(specIndex)       HalLcd_HW_Control(0xC0 | (specIndex))
    149          
    150          /* Set ICONRAM address */
    151          #define CONTRAST_CTRL_REGISTER          0x10
    152          #define SET_ICONRAM_ADDR(addr)          HalLcd_HW_Control(0x40 | (addr))
    153          
    154          /* Set double height */
    155          #define LINE_1_AND_2                    0x01
    156          #define LINE_2_AND_3                    0x02
    157          #define NORMAL_DISPLAY                  0x00
    158          #define SET_DOUBLE_HEIGHT(options)      HalLcd_HW_Control(0x08 | (options))
    159          
    160          /**************************************************************************************************
    161           *                                           MACROS
    162           **************************************************************************************************/
    163          
    164          #define HAL_IO_SET(port, pin, val)        HAL_IO_SET_PREP(port, pin, val)
    165          #define HAL_IO_SET_PREP(port, pin, val)   st( P##port##_##pin## = val; )
    166          
    167          #define HAL_CONFIG_IO_OUTPUT(port, pin, val)      HAL_CONFIG_IO_OUTPUT_PREP(port, pin, val)
    168          #define HAL_CONFIG_IO_OUTPUT_PREP(port, pin, val) st( P##port##SEL &= ~BV(pin); \
    169                                                                P##port##_##pin## = val; \
    170                                                                P##port##DIR |= BV(pin); )
    171          
    172          #define HAL_CONFIG_IO_PERIPHERAL(port, pin)      HAL_CONFIG_IO_PERIPHERAL_PREP(port, pin)
    173          #define HAL_CONFIG_IO_PERIPHERAL_PREP(port, pin) st( P##port##SEL |= BV(pin); )
    174          
    175          
    176          
    177          /* SPI interface control */
    178          #define LCD_SPI_BEGIN()     HAL_IO_SET(HAL_LCD_CS_PORT,  HAL_LCD_CS_PIN,  0); /* chip select */
    179          #define LCD_SPI_END()                                                         \
    180          {                                                                             \
    181            asm("NOP");                                                                 \
    182            asm("NOP");                                                                 \
    183            asm("NOP");                                                                 \
    184            asm("NOP");                                                                 \
    185            HAL_IO_SET(HAL_LCD_CS_PORT,  HAL_LCD_CS_PIN,  1); /* chip select */         \
    186          }
    187          /* clear the received and transmit byte status, write tx data to buffer, wait till transmit done */
    188          #define LCD_SPI_TX(x)                   { U1CSR &= ~(BV(2) | BV(1)); U1DBUF = x; while( !(U1CSR & BV(1)) ); }
    189          #define LCD_SPI_WAIT_RXRDY()            { while(!(U1CSR & BV(1))); }
    190          
    191          
    192          /* Control macros */
    193          #define LCD_DO_WRITE()        HAL_IO_SET(HAL_LCD_MODE_PORT,  HAL_LCD_MODE_PIN,  1);
    194          #define LCD_DO_CONTROL()      HAL_IO_SET(HAL_LCD_MODE_PORT,  HAL_LCD_MODE_PIN,  0);
    195          
    196          #define LCD_ACTIVATE_RESET()  HAL_IO_SET(HAL_LCD_RESET_PORT, HAL_LCD_RESET_PIN, 0);
    197          #define LCD_RELEASE_RESET()   HAL_IO_SET(HAL_LCD_RESET_PORT, HAL_LCD_RESET_PIN, 1);
    198          
    199          
    200          /**************************************************************************************************
    201           *                                       GLOBAL VARIABLES
    202           **************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    203          static uint8 *Lcd_Line1;
                               ^
Warning[Pe550]: variable "Lcd_Line1" was set but never used
   \                     Lcd_Line1:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    204          
    205          /**************************************************************************************************
    206           *                                       FUNCTIONS - API
    207           **************************************************************************************************/
    208          #if (HAL_LCD == TRUE)
    209          void HalLcd_HW_Init(void);
    210          void HalLcd_HW_WaitUs(uint16 i);
    211          void HalLcd_HW_Clear(void);
    212          void HalLcd_HW_ClearAllSpecChars(void);
    213          void HalLcd_HW_Control(uint8 cmd);
    214          void HalLcd_HW_Write(uint8 data);
    215          void HalLcd_HW_SetContrast(uint8 value);
    216          void HalLcd_HW_WriteChar(uint8 line, uint8 col, char text);
    217          void HalLcd_HW_WriteLine(uint8 line, const char *pText);
    218          #endif //LCD
    219          
    220          /**************************************************************************************************
    221           * @fn      HalLcdInit
    222           *
    223           * @brief   Initilize LCD Service
    224           *
    225           * @param   init - pointer to void that contains the initialized value
    226           *
    227           * @return  None
    228           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    229          void HalLcdInit(void)
   \                     HalLcdInit:
    230          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    231            Lcd_Line1 = NULL;
   \   000004   90....       MOV     DPTR,#Lcd_Line1
   \   000007   E4           CLR     A
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   F0           MOVX    @DPTR,A
    232          #if (HAL_LCD == TRUE)
    233            HalLcd_HW_Init();
    234          #endif
    235          }
   \   00000B   D083         POP     DPH
   \   00000D   D082         POP     DPL
   \   00000F   02....       LJMP    ?BRET
    236          
    237          /*************************************************************************************************
    238           *                    LCD EMULATION FUNCTIONS
    239           *
    240           * Some evaluation boards are equipped with Liquid Crystal Displays
    241           * (LCD) which may be used to display diagnostic information. These
    242           * functions provide LCD emulation, sending the diagnostic strings
    243           * to Z-Tool via the RS232 serial port. These functions are enabled
    244           * when the "LCD_SUPPORTED" compiler flag is placed in the makefile.
    245           *
    246           * Most applications update both lines (1 and 2) of the LCD whenever
    247           * text is posted to the device. This emulator assumes that line 1 is
    248           * updated first (saved locally) and the formatting and send operation
    249           * is triggered by receipt of line 2. Nothing will be transmitted if
    250           * only line 1 is updated.
    251           *
    252           *************************************************************************************************/
    253          
    254          
    255          /**************************************************************************************************
    256           * @fn      HalLcdWriteString
    257           *
    258           * @brief   Write a string to the LCD
    259           *
    260           * @param   str    - pointer to the string that will be displayed
    261           *          option - display options
    262           *
    263           * @return  None
    264           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    265          void HalLcdWriteString ( char *str, uint8 option)
   \                     HalLcdWriteString:
    266          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    267          #if (HAL_LCD == TRUE)
    268          
    269            uint8 strLen = 0;
    270            uint8 totalLen = 0;
    271            uint8 *buf;
    272            uint8 tmpLen;
    273          
    274            if ( Lcd_Line1 == NULL )
    275            {
    276              Lcd_Line1 = osal_mem_alloc( HAL_LCD_MAX_CHARS+1 );
    277              HalLcdWriteString( "TexasInstruments", 1 );
    278            }
    279          
    280            strLen = (uint8)osal_strlen( (char*)str );
    281          
    282            /* Check boundries */
    283            if ( strLen > HAL_LCD_MAX_CHARS )
    284              strLen = HAL_LCD_MAX_CHARS;
    285          
    286            if ( option == HAL_LCD_LINE_1 )
    287            {
    288              /* Line 1 gets saved for later */
    289              osal_memcpy( Lcd_Line1, str, strLen );
    290              Lcd_Line1[strLen] = '\0';
    291            }
    292            else
    293            {
    294              /* Line 2 triggers action */
    295              tmpLen = (uint8)osal_strlen( (char*)Lcd_Line1 );
    296              totalLen =  tmpLen + 1 + strLen + 1;
    297              buf = osal_mem_alloc( totalLen );
    298              if ( buf != NULL )
    299              {
    300                /* Concatenate strings */
    301                osal_memcpy( buf, Lcd_Line1, tmpLen );
    302                buf[tmpLen++] = ' ';
    303                osal_memcpy( &buf[tmpLen], str, strLen );
    304                buf[tmpLen+strLen] = '\0';
    305          
    306                /* Send it out */
    307          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    308          
    309          #if defined(SERIAL_DEBUG_SUPPORTED)
    310                debug_str( (uint8*)buf );
    311          #endif //LCD_SUPPORTED
    312          
    313          #endif //ZTOOL_P1
    314          
    315                /* Free mem */
    316                osal_mem_free( buf );
    317              }
    318            }
    319          
    320            /* Display the string */
    321            HalLcd_HW_WriteLine (option, str);
    322          
    323          #endif //HAL_LCD
    324          
    325          }
   \   000000   02....       LJMP    ?BRET
    326          
    327          /**************************************************************************************************
    328           * @fn      HalLcdWriteValue
    329           *
    330           * @brief   Write a value to the LCD
    331           *
    332           * @param   value  - value that will be displayed
    333           *          radix  - 8, 10, 16
    334           *          option - display options
    335           *
    336           * @return  None
    337           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    338          void HalLcdWriteValue ( uint32 value, const uint8 radix, uint8 option)
   \                     HalLcdWriteValue:
    339          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    340          #if (HAL_LCD == TRUE)
    341            uint8 buf[LCD_MAX_BUF];
    342          
    343            _ltoa( value, &buf[0], radix );
    344            HalLcdWriteString( (char*)buf, option );
    345          #endif
    346          }
   \   000000   02....       LJMP    ?BRET
    347          
    348          /**************************************************************************************************
    349           * @fn      HalLcdWriteScreen
    350           *
    351           * @brief   Write a value to the LCD
    352           *
    353           * @param   line1  - string that will be displayed on line 1
    354           *          line2  - string that will be displayed on line 2
    355           *
    356           * @return  None
    357           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    358          void HalLcdWriteScreen( char *line1, char *line2 )
   \                     HalLcdWriteScreen:
    359          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    360          #if (HAL_LCD == TRUE)
    361            HalLcdWriteString( line1, 1 );
    362            HalLcdWriteString( line2, 2 );
    363          #endif
    364          }
   \   000000   02....       LJMP    ?BRET
    365          
    366          /**************************************************************************************************
    367           * @fn      HalLcdWriteStringValue
    368           *
    369           * @brief   Write a string followed by a value to the LCD
    370           *
    371           * @param   title  - Title that will be displayed before the value
    372           *          value  - value
    373           *          format - redix
    374           *          line   - line number
    375           *
    376           * @return  None
    377           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    378          void HalLcdWriteStringValue( char *title, uint16 value, uint8 format, uint8 line )
   \                     HalLcdWriteStringValue:
    379          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    380          #if (HAL_LCD == TRUE)
    381            uint8 tmpLen;
    382            uint8 buf[LCD_MAX_BUF];
    383            uint32 err;
    384          
    385            tmpLen = (uint8)osal_strlen( (char*)title );
    386            osal_memcpy( buf, title, tmpLen );
    387            buf[tmpLen] = ' ';
    388            err = (uint32)(value);
    389            _ltoa( err, &buf[tmpLen+1], format );
    390            HalLcdWriteString( (char*)buf, line );		
    391          #endif
    392          }
   \   000000   02....       LJMP    ?BRET
    393          
    394          /**************************************************************************************************
    395           * @fn      HalLcdWriteStringValue
    396           *
    397           * @brief   Write a string followed by a value to the LCD
    398           *
    399           * @param   title   - Title that will be displayed before the value
    400           *          value1  - value #1
    401           *          format1 - redix of value #1
    402           *          value2  - value #2
    403           *          format2 - redix of value #2
    404           *          line    - line number
    405           *
    406           * @return  None
    407           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    408          void HalLcdWriteStringValueValue( char *title, uint16 value1, uint8 format1,
   \                     HalLcdWriteStringValueValue:
    409                                            uint16 value2, uint8 format2, uint8 line )
    410          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    411          
    412          #if (HAL_LCD == TRUE)
    413          
    414            uint8 tmpLen;
    415            uint8 buf[LCD_MAX_BUF];
    416            uint32 err;
    417          
    418            tmpLen = (uint8)osal_strlen( (char*)title );
    419            if ( tmpLen )
    420            {
    421              osal_memcpy( buf, title, tmpLen );
    422              buf[tmpLen++] = ' ';
    423            }
    424          
    425            err = (uint32)(value1);
    426            _ltoa( err, &buf[tmpLen], format1 );
    427            tmpLen = (uint8)osal_strlen( (char*)buf );
    428          
    429            buf[tmpLen++] = ',';
    430            buf[tmpLen++] = ' ';
    431            err = (uint32)(value2);
    432            _ltoa( err, &buf[tmpLen], format2 );
    433          
    434            HalLcdWriteString( (char *)buf, line );		
    435          
    436          #endif
    437          }
   \   000000   02....       LJMP    ?BRET
    438          
    439          /**************************************************************************************************
    440           * @fn      HalLcdDisplayPercentBar
    441           *
    442           * @brief   Display percentage bar on the LCD
    443           *
    444           * @param   title   -
    445           *          value   -
    446           *
    447           * @return  None
    448           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    449          void HalLcdDisplayPercentBar( char *title, uint8 value )
   \                     HalLcdDisplayPercentBar:
    450          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    451          #if (HAL_LCD == TRUE)
    452          
    453            uint8 percent;
    454            uint8 leftOver;
    455            uint8 buf[17];
    456            uint32 err;
    457            uint8 x;
    458          
    459            /* Write the title: */
    460            HalLcdWriteString( title, HAL_LCD_LINE_1 );
    461          
    462            if ( value > 100 )
    463              value = 100;
    464          
    465            /* convert to blocks */
    466            percent = (uint8)(value / 10);
    467            leftOver = (uint8)(value % 10);
    468          
    469            /* Make window */
    470            osal_memcpy( buf, "[          ]  ", 15 );
    471          
    472            for ( x = 0; x < percent; x ++ )
    473            {
    474              buf[1+x] = '>';
    475            }
    476          
    477            if ( leftOver >= 5 )
    478              buf[1+x] = '+';
    479          
    480            err = (uint32)value;
    481            _ltoa( err, (uint8*)&buf[13], 10 );
    482          
    483            HalLcdWriteString( (char*)buf, HAL_LCD_LINE_2 );
    484          
    485          #endif
    486          
    487          }
   \   000000   02....       LJMP    ?BRET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteString?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteString

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteValue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteScreen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteScreen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteStringValue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteStringValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteStringValueValue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteStringValueValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdDisplayPercentBar?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdDisplayPercentBar
    488          
    489          
    490          #if (HAL_LCD == TRUE)
    491          /**************************************************************************************************
    492           *                                    HARDWARE LCD
    493           **************************************************************************************************/
    494          
    495          /**************************************************************************************************
    496           * @fn      halLcd_ConfigIO
    497           *
    498           * @brief   Configure IO lines needed for LCD control.
    499           *
    500           * @param   None
    501           *
    502           * @return  None
    503           **************************************************************************************************/
    504          static void halLcd_ConfigIO(void)
    505          {
    506            /* GPIO configuration */
    507            HAL_CONFIG_IO_OUTPUT(HAL_LCD_MODE_PORT,  HAL_LCD_MODE_PIN,  1);
    508            HAL_CONFIG_IO_OUTPUT(HAL_LCD_RESET_PORT, HAL_LCD_RESET_PIN, 1);
    509            HAL_CONFIG_IO_OUTPUT(HAL_LCD_CS_PORT,    HAL_LCD_CS_PIN,    1);
    510          }
    511          
    512          /**************************************************************************************************
    513           * @fn      halLcd_ConfigSPI
    514           *
    515           * @brief   Configure SPI lines needed for talking to LCD.
    516           *
    517           * @param   None
    518           *
    519           * @return  None
    520           **************************************************************************************************/
    521          static void halLcd_ConfigSPI(void)
    522          {
    523            /* UART/SPI Peripheral configuration */
    524          
    525             uint8 baud_exponent;
    526             uint8 baud_mantissa;
    527          
    528            /* Set SPI on UART 1 alternative 2 */
    529            PERCFG |= 0x02;
    530          
    531            /* Configure clk, master out and master in lines */
    532            HAL_CONFIG_IO_PERIPHERAL(HAL_LCD_CLK_PORT,  HAL_LCD_CLK_PIN);
    533            HAL_CONFIG_IO_PERIPHERAL(HAL_LCD_MOSI_PORT, HAL_LCD_MOSI_PIN);
    534            HAL_CONFIG_IO_PERIPHERAL(HAL_LCD_MISO_PORT, HAL_LCD_MISO_PIN);
    535          
    536          
    537            /* Set SPI speed to 1 MHz (the values assume system clk of 32MHz)
    538             * Confirm on board that this results in 1MHz spi clk.
    539             */
    540            baud_exponent = 15;
    541            baud_mantissa =  0;
    542          
    543            /* Configure SPI */
    544            U1UCR  = 0x80;      /* Flush and goto IDLE state. 8-N-1. */
    545            U1CSR  = 0x00;      /* SPI mode, master. */
    546            U1GCR  = HAL_SPI_TRANSFER_MSB_FIRST | HAL_SPI_CLOCK_PHA_0 | HAL_SPI_CLOCK_POL_LO | baud_exponent;
    547            U1BAUD = baud_mantissa;
    548          }
    549          
    550          /**************************************************************************************************
    551           * @fn      HalLcd_HW_Init
    552           *
    553           * @brief   Initilize HW LCD Driver.
    554           *
    555           * @param   None
    556           *
    557           * @return  None
    558           **************************************************************************************************/
    559          void HalLcd_HW_Init(void)
    560          {
    561            /* Initialize LCD IO lines */
    562            halLcd_ConfigIO();
    563          
    564            /* Initialize SPI */
    565            halLcd_ConfigSPI();
    566          
    567            /* Perform reset */
    568            LCD_ACTIVATE_RESET();
    569            HalLcd_HW_WaitUs(15000); // 15 ms
    570            LCD_RELEASE_RESET();
    571            HalLcd_HW_WaitUs(15); // 15 us
    572          
    573            /* Perform the initialization sequence */
    574            FUNCTION_SET(CGRAM | COM_FORWARD | THREE_LINE);
    575          
    576            /* Set contrast */
    577            HalLcd_HW_SetContrast(15);
    578          
    579            /* Set power */
    580            SET_POWER_SAVE_MODE(OSC_OFF | POWER_SAVE_ON);
    581            SET_POWER_CTRL(VOLTAGE_DIVIDER_ON | CONVERTER_AND_REG_ON);
    582            SET_BIAS_CTRL(BIAS_1_5);
    583            HalLcd_HW_WaitUs(21000);// 21 ms
    584          
    585            /* Clear the display */
    586            HalLcd_HW_Clear();
    587            HalLcd_HW_ClearAllSpecChars();
    588            SET_DISPLAY_CTRL(DISPLAY_CTRL_ON | DISPLAY_CTRL_BLINK_OFF | DISPLAY_CTRL_CURSOR_OFF);
    589          }
    590          
    591          /**************************************************************************************************
    592           * @fn      HalLcd_HW_Control
    593           *
    594           * @brief   Write 1 command to the LCD
    595           *
    596           * @param   uint8 cmd - command to be written to the LCD
    597           *
    598           * @return  None
    599           **************************************************************************************************/
    600          void HalLcd_HW_Control(uint8 cmd)
    601          {
    602            LCD_SPI_BEGIN();
    603            LCD_DO_CONTROL();
    604            LCD_SPI_TX(cmd);
    605            LCD_SPI_WAIT_RXRDY();
    606            LCD_SPI_END();
    607          }
    608          
    609          /**************************************************************************************************
    610           * @fn      HalLcd_HW_Write
    611           *
    612           * @brief   Write 1 byte to the LCD
    613           *
    614           * @param   uint8 data - data to be written to the LCD
    615           *
    616           * @return  None
    617           **************************************************************************************************/
    618          void HalLcd_HW_Write(uint8 data)
    619          {
    620            LCD_SPI_BEGIN();
    621            LCD_DO_WRITE();
    622            LCD_SPI_TX(data);
    623            LCD_SPI_WAIT_RXRDY();
    624            LCD_SPI_END();
    625          }
    626          
    627          /**************************************************************************************************
    628           * @fn          HalLcd_HW_SetContrast
    629           *
    630           * @brief       Set display contrast
    631           *
    632           * @param       uint8 value - contrast value
    633           *
    634           * @return      none
    635           **************************************************************************************************/
    636          void HalLcd_HW_SetContrast(uint8 value)
    637          {
    638            SET_ICONRAM_ADDR(CONTRAST_CTRL_REGISTER);
    639            HalLcd_HW_Write(value);
    640          }
    641          
    642          /**************************************************************************************************
    643           * @fn      HalLcd_HW_Clear
    644           *
    645           * @brief   Clear the HW LCD
    646           *
    647           * @param   None
    648           *
    649           * @return  None
    650           **************************************************************************************************/
    651          void HalLcd_HW_Clear(void)
    652          {
    653            uint8 n;
    654          
    655            SET_DDRAM_ADDR(0x00);
    656            for (n = 0; n < (LCD_MAX_LINE_COUNT * LCD_MAX_LINE_LENGTH); n++)
    657            {
    658              HalLcd_HW_Write(' ');
    659            }
    660          }
    661          
    662          /**************************************************************************************************
    663           * @fn      HalLcd_HW_ClearAllSpecChars
    664           *
    665           * @brief   Clear all special chars
    666           *
    667           * @param   None
    668           *
    669           * @return  None
    670           **************************************************************************************************/
    671          void HalLcd_HW_ClearAllSpecChars(void)
    672          {
    673            uint8 n = 0;
    674          
    675            SET_GCRAM_CHAR(0);
    676            for (n = 0; n < (8 * 8); n++)
    677            {
    678              HalLcd_HW_Write(0x00);
    679            }
    680          }
    681          
    682          /**************************************************************************************************
    683           * @fn      HalLcd_HW_WriteChar
    684           *
    685           * @brief   Write one char to the display
    686           *
    687           * @param   uint8 line - line number that the char will be displayed
    688           *          uint8 col - colum where the char will be displayed
    689           *
    690           * @return  None
    691           **************************************************************************************************/
    692          void HalLcd_HW_WriteChar(uint8 line, uint8 col, char text)
    693          {
    694            if (col < LCD_MAX_LINE_LENGTH)
    695            {
    696              SET_DDRAM_ADDR((line - 1) * LCD_MAX_LINE_LENGTH + col);
    697              HalLcd_HW_Write(text);
    698            }
    699            else
    700            {
    701              return;
    702            }
    703          }
    704          
    705          /**************************************************************************************************
    706           * @fn          halLcdWriteLine
    707           *
    708           * @brief       Write one line on display
    709           *
    710           * @param       uint8 line - display line
    711           *              char *pText - text buffer to write
    712           *
    713           * @return      none
    714           **************************************************************************************************/
    715          void HalLcd_HW_WriteLine(uint8 line, const char *pText)
    716          {
    717            uint8 count;
    718            uint8 totalLength = (uint8)osal_strlen( (char *)pText );
    719          
    720            /* Write the content first */
    721            for (count=0; count<totalLength; count++)
    722            {
    723              HalLcd_HW_WriteChar(line, count, (*(pText++)));
    724            }
    725          
    726            /* Write blank spaces to rest of the line */
    727            for(count=totalLength; count<LCD_MAX_LINE_LENGTH;count++)
    728            {
    729              HalLcd_HW_WriteChar(line, count, ' ');
    730            }
    731          }
    732          
    733          /**************************************************************************************************
    734           * @fn      HalLcd_HW_WaitUs
    735           *
    736           * @brief   wait for x us. @ 32MHz MCU clock it takes 32 "nop"s for 1 us delay.
    737           *
    738           * @param   x us. range[0-65536]
    739           *
    740           * @return  None
    741           **************************************************************************************************/
    742          void HalLcd_HW_WaitUs(uint16 microSecs)
    743          {
    744            while(microSecs--)
    745            {
    746              /* 32 NOPs == 1 usecs */
    747              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    748              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    749              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    750              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    751              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    752              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    753              asm("nop"); asm("nop");
    754            }
    755          }
    756          #endif
    757          
    758          
    759          /**************************************************************************************************
    760          **************************************************************************************************/
    761          
    762          
    763          

   Maximum stack usage in bytes:

     Function                    ISTACK PSTACK XSTACK
     --------                    ------ ------ ------
     HalLcdDisplayPercentBar         0      0      0
     HalLcdInit                      2      0      0
     HalLcdWriteScreen               0      0      0
     HalLcdWriteString               0      0      0
     HalLcdWriteStringValue          0      0      1
     HalLcdWriteStringValueValue     0      0      4
     HalLcdWriteValue                0      0      1


   Segment part sizes:

     Function/Label                      Bytes
     --------------                      -----
     Lcd_Line1                              2
     HalLcdInit                            18
     HalLcdWriteString                      3
     HalLcdWriteValue                       3
     HalLcdWriteScreen                      3
     HalLcdWriteStringValue                 3
     HalLcdWriteStringValueValue            3
     HalLcdDisplayPercentBar                3
     ??HalLcdInit?relay                     6
     ??HalLcdWriteString?relay              6
     ??HalLcdWriteValue?relay               6
     ??HalLcdWriteScreen?relay              6
     ??HalLcdWriteStringValue?relay         6
     ??HalLcdWriteStringValueValue?relay    6
     ??HalLcdDisplayPercentBar?relay        6

 
 36 bytes in segment BANKED_CODE
 42 bytes in segment BANK_RELAYS
  2 bytes in segment XDATA_Z
 
 78 bytes of CODE  memory
  2 bytes of XDATA memory

Errors: none
Warnings: 1
